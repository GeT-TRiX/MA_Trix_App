% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/final.R
\name{hmbis}
\alias{hmbis}
\alias{hmbis}
\title{hmbis is an event reactive function that pre-computed hierarchical clustering on microarray data}
\usage{
hmbis()

hmbis()
}
\arguments{
\item{new_data}{a data frame with all the individuals selected}

\item{formated}{a data frame with the indexes corresponding to the sigificant genes}

\item{new_group}{a data frame with the corresponding groups}

\item{workingPath}{the current user's repository}

\item{k}{a numeric value which aim is to defined the treshold value to cut the dendogram input$clusters}

\item{Rowdistfun}{a function used to compute the distance for the rows}

\item{Coldistfun}{a function used to compute the distance for the columns}

\item{meanGrp}{a boolean value to computes the mean for each groups; default = F}

\item{genename}{a data frame}

\item{new_data}{a data frame with all the individuals selected}

\item{formated}{a data frame with the indexes corresponding to the sigificant genes}

\item{new_group}{a data frame with the corresponding groups}

\item{workingPath}{the current user's repository}

\item{k}{a numeric value which aim is to defined the treshold value to cut the dendogram input$clusters}

\item{Rowdistfun}{a function used to compute the distance for the rows}

\item{Coldistfun}{a function used to compute the distance for the columns}

\item{meanGrp}{a boolean value to computes the mean for each groups; default = F}

\item{genename}{a data frame}
}
\value{
a list of objects which aim is to being passed as argument in the plotHeatmaps function

a list of objects which aim is to being passed as argument in the plotHeatmaps function
}
\description{
hmbis is an event reactive function that pre-computed hierarchical clustering on microarray data

shinyjs::enable("heatm")
}
\details{
heatmapfinal <- function(isplot  = T) {
  if (is.null(my_intermediate()))
    mypal = (colorRampPalette(c("green", "black", "red"))(n = 75))
  else
    mypal = isolate((colorRampPalette(c(
      choix_col1(), my_intermediate(), choix_col3()
    ))(n = 75)))

plotHeatmaps(
    heatmapobj[[1]],
    geneSet =  hmbis()[[7]],
    droplevels(new_group()$Grp),
    workingPath = wd_path,
    my_palette = colorRampPalette(c(
      choix_col1(), my_intermediate(), choix_col3()
    ))(n = 75),
    mycex = input$legsize ,
    cexrow = input$rowsize ,
    cexcol = input$colsize ,
    mypal =  unlist(colors()),
    showcol = colname(),
    showrow = rowname(),
    genename =  csvf()[[3]],
    notplot = isplot,
    rowv = heatmapobj[[4]],
    ColvOrd = heatmapobj[[3]],
    gpcol = heatmapobj[[5]],
    gpcolr = heatmapobj[[6]],
    distfunTRIX = heatmapobj[[2]],
    height = heatmapobj[[8]]
  )
}

# heatmapfinal <- function(isplot  = F) {
#   if(is.null(my_intermediate()))
#     mypal = (colorRampPalette(c(
#       "green", "black", "red"))(n = 75))
#   else
#     mypal= (colorRampPalette(c(
#       choix_col1(), my_intermediate(), choix_col3()))(n = 75))
#
#
#   plotHeatmaps(
#     hmbis()[[1]],
#     geneSet =  hmbis()[[7]],
#     droplevels(new_group()$Grp),
#     workingPath = wd_path,
#     my_palette = (colorRampPalette(c(
#       choix_col1(), my_intermediate(), choix_col3()))(n = 75)),#mypal,
#     mycex = input$legsize ,
#     cexrow = input$rowsize ,
#     cexcol = input$colsize ,
#     mypal =  unlist(colors()),
#     showcol = colname(),
#     showrow = rowname(),
#     genename =  csvf()[[3]],
#     notplot = isplot,
#     rowv = hmbis()[[4]],
#     ColvOrd = hmbis()[[3]],
#     gpcol = hmbis()[[5]],
#     gpcolr = hmbis()[[6]],
#     distfunTRIX = hmbis()[[2]],
#     height = hmbis()[[8]]
#   )
#
# }



#' hmbis is an event reactive function that pre-computed hierarchical clustering on microarray data
#'
#' @param new_data a data frame with all the individuals selected
#' @param formated  a data frame with the indexes corresponding to the sigificant genes
#' @param new_group  a data frame with the corresponding groups
#' @param workingPath the current user's repository
#' @param k a numeric value which aim is to defined the treshold value to cut the dendogram input$clusters
#' @param Rowdistfun a function used to compute the distance for the rows
#' @param Coldistfun a function used to compute the distance for the columns
#' @param meanGrp a boolean value to computes the mean for each groups; default = F
#'
#' @return  a list of objects which aim is to being passed as argument in the plotHeatmaps function
#'
#' @export
#'

hmbis <- eventReactive(input$heatm, {
  withProgress(message = 'Performing the hierarchical clustering:', # Add sliderbar when loading heatmap
                       value = 0,
                       {
                         #n <- NROW(formated()[[1]]) #number of row in the formated dataframe
                         n = 500
                         for (i in 1:n) {
                           incProgress(1 / n, detail = "Please wait...")
                         }

truncatedhat(
                           data.matrix(new_data()),
                           formated()[[1]],
                           droplevels(new_group()$Grp),
                           workingPath = wd_path,
                           k = input$clusters,
                           mypal = unlist(colors()),
                           Rowdistfun = input$dist ,
                           Coldistfun = input$dist,
                           meanGrp = input$meangrp,
                           genename =  csvf()[[3]]
                         )
                       })

#dev.off()
  # isolate in order to avoid that reactive values update the heatmap)
})

heatmapobj <<- hmbis() # a static variable

observe(if (is.null(my_intermediate())) {
  isolate(heatmapfinal(isplot = F))
  shinyjs::alert("your choice color are not fit to be together!!")
}
else
  output$distPlot <- renderPlot({

validate(
      need(csvf(), 'You need to import data to visualize this plot!'))

isolate({
      if (!is.null(formated()[[2]]))
        withProgress(message = 'Plotting heatmap:', # Add sliderbar when loading heatmap
                     value = 0,
                     {

#n <- NROW(formated()[[1]]) #number of row in the formated dataframe
                       n <- 500
                       for (i in 1:n) {
                         incProgress(1 / n, detail = "Please wait...")
                       }



observe({boolhm <<-T})

output$heatmbool <- reactive({
                         boolhm
                       })

#hmbis()

hmobj$hm = heatmapfinal(isplot = F)
                       hmobj$hm

})
    })
  }, width = 900 , height = 1200, res = 100))
hmbis is an event reactive function that pre-computed hierarchical clustering on microarray data
}
